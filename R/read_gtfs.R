#' Read and validate GTFS files
#'
#' Reads GTFS text files from a zip file and validates them against GTFS
#' specifications.
#'
#' @param path The path to a GTFS \code{.zip} file.
#' @param files A character vector containing the text files to be read from the
#'   GTFS (without the \code{.txt} extension). If \code{NULL} (the default) all
#'   existing files are read.
#' @param quiet Whether to display warning messages (the default) or not.
#'
#' @return A GTFS object: a list of data.tables in which each index represents a
#'   GTFS text file.
#'
#' @export
read_gtfs <- function(path, files = NULL, quiet = FALSE) {

  # unzip files

  checkmate::assert_file_exists(path)

  files_in_gtfs <- unzip(path, list = TRUE)$Name

  if (is.null(files)) {

    files_to_read <- files_in_gtfs

  } else {

    checkmate::assert_names(files, subset.of = sub(".txt", "", files_in_gtfs))

    files_to_read <- paste0(files, ".txt")

  }

  temp_dir <- file.path(tempdir(), "gtfsdir")
  unlink(temp_dir, recursive = TRUE)
  utils::unzip(path, files = files_to_read, exdir = temp_dir, overwrite = TRUE)

  # read files into list and assign GTFS class

  gtfs <- lapply(files_to_read, read_files, temp_dir)
  gtfs <- stats::setNames(gtfs, sub(".txt", "", files_to_read))
  class(gtfs) <- "gtfs"

  # check if any parsing warnings were thrown

  files_class <- lapply(gtfs, class)
  has_warning <- unlist(lapply(files_class, function(i) "warning" %in% i))

  if (sum(has_warning) >= 1) {

    gtfs_warnings <- gtfs[has_warning]
    gtfs_warnings <- lapply(gtfs_warnings, extract_warning_message)

    if (!quiet) {
      warning(
        paste0(
          "Parsing failures while reading ",
          paste(names(gtfs_warnings), collapse = ", ")
        )
      )
    }

    return(gtfs_warnings)

  }

  # if not, validate given GTFS structure against specifications

  validation_result <- validate_gtfs(gtfs, files, quiet)
  attr(gtfs, "validation_result") <- validation_result

  return(gtfs)

}

#' Read GTFS text files
#'
#' Reads a text file from the main zip file.
#'
#' @param file The name of the file (with \code{.txt} extension) to be read.
#' @param temp_dir The path to the temporary folder where the GTFS was unzipped.
#'
#' @return Either a data.table containing the desired file or a log message if
#'   any parsing warnings were thrown.
read_files <- function(file, temp_dir) {

  gtfs_metadata <- get_gtfs_meta()

  # check if given file is a valid gtfs file

  all_possible_files <- names(gtfs_metadata)

  checkmate::assert_names(file, subset.of = all_possible_files, .var.name = file)

  file_metadata <- gtfs_metadata[[file]]

  # read first row to know what columns to read

  sample_dt   <- suppressWarnings(
    data.table::fread(file.path(temp_dir, file), nrows = 1)
  )

  # if file is completely empty (without even a header) return NULL data.table

  if (ncol(sample_dt) == 0) return(data.table::data.table(NULL))

  # read full file. if a parsing warning has been thrown save it

  col_to_read <- names(sample_dt)
  col_classes <- file_metadata$coltype[col_to_read]

  full_dt <- tryCatch(
    data.table::fread(file.path(temp_dir, file), select = col_classes),
    warning = function(w) w
  )

  return(full_dt)

}

#' Extract warning message
#'
#' Extracts the warning message as a string from a warning log.
#'
#' @param warning_log Warning log generated by \code{data.table::fread}.
#'
#' @return A string containing details on the parsing failure.
extract_warning_message <- function(warning_log) {

  warning_log <- as.character(warning_log)

  warning_message <- regmatches(
    warning_log,
    regexpr(
      "Stopped early on line \\d+. Expected \\d+ fields but found \\d+.",
      warning_log
    )
  )

  return(warning_message)

}
